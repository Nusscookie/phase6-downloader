import {
  PDFDocument,
  PDFEmbeddedPage_default,
  PDFPage_default,
  browser_module_exports,
  builtInPlugins,
  checkGenerateProps,
  cloneDeep,
  getB64BasePdf,
  getDynamicHeightsForTable,
  getDynamicTemplate,
  isBlankPdf,
  mm2pt,
  pluginRegistry,
  pt2mm,
  replacePlaceholders,
  src_exports
} from "./chunk-KC7F7IN3.js";
import "./chunk-PR4QN5HX.js";

// node_modules/@pdfme/generator/dist/esm/src/constants.js
var TOOL_NAME = "pdfme (https://pdfme.com/)";

// node_modules/@pdfme/generator/dist/esm/src/helper.js
var getEmbedPdfPages = async (arg) => {
  const { template: { schemas, basePdf }, pdfDoc } = arg;
  let basePages = [];
  let embedPdfBoxes = [];
  if (isBlankPdf(basePdf)) {
    const { width: _width, height: _height } = basePdf;
    const width = mm2pt(_width);
    const height = mm2pt(_height);
    basePages = schemas.map(() => {
      const page = PDFPage_default.create(pdfDoc);
      page.setSize(width, height);
      return page;
    });
    embedPdfBoxes = schemas.map(() => ({
      mediaBox: { x: 0, y: 0, width, height },
      bleedBox: { x: 0, y: 0, width, height },
      trimBox: { x: 0, y: 0, width, height }
    }));
  } else {
    const willLoadPdf = await getB64BasePdf(basePdf);
    const embedPdf = await PDFDocument.load(willLoadPdf);
    const embedPdfPages = embedPdf.getPages();
    embedPdfBoxes = embedPdfPages.map((p) => ({
      mediaBox: p.getMediaBox(),
      bleedBox: p.getBleedBox(),
      trimBox: p.getTrimBox()
    }));
    const boundingBoxes = embedPdfPages.map((p) => {
      const { x, y, width, height } = p.getMediaBox();
      return { left: x, bottom: y, right: width, top: height + y };
    });
    const transformationMatrices = embedPdfPages.map(() => [1, 0, 0, 1, 0, 0]);
    basePages = await pdfDoc.embedPages(embedPdfPages, boundingBoxes, transformationMatrices);
  }
  return { basePages, embedPdfBoxes };
};
var validateRequiredFields = (template, inputs) => {
  template.schemas.forEach((schemaPage) => schemaPage.forEach((schema) => {
    if (schema.required && !schema.readOnly && !inputs.some((input) => input[schema.name])) {
      throw new Error(`[@pdfme/generator] input for '${schema.name}' is required to generate this PDF`);
    }
  }));
};
var preprocessing = async (arg) => {
  const { template, userPlugins } = arg;
  const { schemas, basePdf } = template;
  const staticSchema = isBlankPdf(basePdf) ? basePdf.staticSchema ?? [] : [];
  const pdfDoc = await PDFDocument.create();
  pdfDoc.registerFontkit(browser_module_exports);
  const plugins = pluginRegistry(Object.values(userPlugins).length > 0 ? userPlugins : builtInPlugins);
  const schemaTypes = Array.from(new Set(schemas.flatMap((schemaPage) => schemaPage.map((schema) => schema.type)).concat(staticSchema.map((schema) => schema.type))));
  const renderObj = schemaTypes.reduce((acc, type) => {
    const plugin = plugins.findByType(type);
    if (!plugin || !plugin.pdf) {
      throw new Error(`[@pdfme/generator] Plugin or renderer for type ${type} not found.
Check this document: https://pdfme.com/docs/custom-schemas`);
    }
    return {
      ...acc,
      [type]: plugin.pdf
    };
  }, {});
  return { pdfDoc, renderObj };
};
var postProcessing = (props) => {
  const { pdfDoc, options } = props;
  const { author = TOOL_NAME, creationDate = /* @__PURE__ */ new Date(), creator = TOOL_NAME, keywords = [], lang = "en", modificationDate = /* @__PURE__ */ new Date(), producer = TOOL_NAME, subject = "", title = "" } = options;
  pdfDoc.setAuthor(author);
  pdfDoc.setCreationDate(creationDate);
  pdfDoc.setCreator(creator);
  pdfDoc.setKeywords(keywords);
  pdfDoc.setLanguage(lang);
  pdfDoc.setModificationDate(modificationDate);
  pdfDoc.setProducer(producer);
  pdfDoc.setSubject(subject);
  pdfDoc.setTitle(title);
};
var insertPage = (arg) => {
  const { basePage, embedPdfBox, pdfDoc } = arg;
  const size = basePage instanceof PDFEmbeddedPage_default ? basePage.size() : basePage.getSize();
  const insertedPage = basePage instanceof PDFEmbeddedPage_default ? pdfDoc.addPage([size.width, size.height]) : pdfDoc.addPage(basePage);
  if (basePage instanceof PDFEmbeddedPage_default) {
    insertedPage.drawPage(basePage);
    const { mediaBox, bleedBox, trimBox } = embedPdfBox;
    insertedPage.setMediaBox(mediaBox.x, mediaBox.y, mediaBox.width, mediaBox.height);
    insertedPage.setBleedBox(bleedBox.x, bleedBox.y, bleedBox.width, bleedBox.height);
    insertedPage.setTrimBox(trimBox.x, trimBox.y, trimBox.width, trimBox.height);
  }
  return insertedPage;
};

// node_modules/@pdfme/generator/dist/esm/src/generate.js
var generate = async (props) => {
  checkGenerateProps(props);
  const { inputs, template: _template, options = {}, plugins: userPlugins = {} } = props;
  const template = cloneDeep(_template);
  const basePdf = template.basePdf;
  if (inputs.length === 0) {
    throw new Error("[@pdfme/generator] inputs should not be empty, pass at least an empty object in the array");
  }
  validateRequiredFields(template, inputs);
  const { pdfDoc, renderObj } = await preprocessing({ template, userPlugins });
  const _cache = /* @__PURE__ */ new Map();
  for (let i = 0; i < inputs.length; i += 1) {
    const input = inputs[i];
    const dynamicTemplate = await getDynamicTemplate({
      template,
      input,
      options,
      _cache,
      getDynamicHeights: (value, args) => {
        switch (args.schema.type) {
          case "table":
            return getDynamicHeightsForTable(value, args);
          default:
            return Promise.resolve([args.schema.height]);
        }
      }
    });
    const { basePages, embedPdfBoxes } = await getEmbedPdfPages({
      template: dynamicTemplate,
      pdfDoc
    });
    const schemas = dynamicTemplate.schemas;
    const schemaNameSet = /* @__PURE__ */ new Set();
    schemas.forEach((page) => {
      page.forEach((schema) => {
        if (schema.name) {
          schemaNameSet.add(schema.name);
        }
      });
    });
    const schemaNames = Array.from(schemaNameSet);
    for (let j = 0; j < basePages.length; j += 1) {
      const basePage = basePages[j];
      const embedPdfBox = embedPdfBoxes[j];
      const boundingBoxLeft = basePage instanceof PDFEmbeddedPage_default ? pt2mm(embedPdfBox.mediaBox.x) : 0;
      const boundingBoxBottom = basePage instanceof PDFEmbeddedPage_default ? pt2mm(embedPdfBox.mediaBox.y) : 0;
      const page = insertPage({ basePage, embedPdfBox, pdfDoc });
      if (isBlankPdf(basePdf) && basePdf.staticSchema) {
        for (let k = 0; k < basePdf.staticSchema.length; k += 1) {
          const staticSchema = basePdf.staticSchema[k];
          const render = renderObj[staticSchema.type];
          if (!render) {
            continue;
          }
          const value = staticSchema.readOnly ? replacePlaceholders({
            content: staticSchema.content || "",
            variables: { ...input, totalPages: basePages.length, currentPage: j + 1 },
            schemas
            // Use the properly typed schemas variable
          }) : staticSchema.content || "";
          staticSchema.position = {
            x: staticSchema.position.x + boundingBoxLeft,
            y: staticSchema.position.y - boundingBoxBottom
          };
          const staticRenderProps = {
            value,
            schema: staticSchema,
            basePdf,
            pdfLib: src_exports,
            pdfDoc,
            page,
            options,
            _cache
          };
          await render(staticRenderProps);
        }
      }
      for (let l = 0; l < schemaNames.length; l += 1) {
        const name = schemaNames[l];
        const schemaPage = schemas[j] || [];
        const schema = schemaPage.find((s) => s.name == name);
        if (!schema) {
          continue;
        }
        const render = renderObj[schema.type];
        if (!render) {
          continue;
        }
        const value = schema.readOnly ? replacePlaceholders({
          content: schema.content || "",
          variables: { ...input, totalPages: basePages.length, currentPage: j + 1 },
          schemas
          // Use the properly typed schemas variable
        }) : input[name] || "";
        schema.position = {
          x: schema.position.x + boundingBoxLeft,
          y: schema.position.y - boundingBoxBottom
        };
        const renderProps = {
          value,
          schema,
          basePdf,
          pdfLib: src_exports,
          pdfDoc,
          page,
          options,
          _cache
        };
        await render(renderProps);
      }
    }
  }
  postProcessing({ pdfDoc, options });
  return pdfDoc.save();
};
var generate_default = generate;
export {
  generate_default as generate
};
//# sourceMappingURL=@pdfme_generator.js.map
